{"prompt": "You are an expert for writing evaluation functions in Python to evaluate whether a response strictly follows an instruction.\nHere is the instruction: Respond with a series of mathematical equations that form a coherent answer. Answer by creating a recipe with each ingredient starting with the next letter of the alphabet\nPlease write a Python function named `evaluate` to evaluate whether an input string `response` follows this instruction. If it follows, simply return True, otherwise return False.\nPlease response with a single JSON includes the evaluation function in the key `func`, and a list of three test cases in the key `cases`, which includes an input in the key `input` and an expected output in the key `output` in (true, false).\nHere is an example of output JSON format: {\"func\": JSON_STR(use only \\n instead of \n), \"cases\": [{\"input\": str, \"output\": str}]}.", "instruction": "Respond with a series of mathematical equations that form a coherent answer. Answer by creating a recipe with each ingredient starting with the next letter of the alphabet", "gpt-answer": ["```json\n{\n  \"func\": \"def evaluate(response):\\n    # Ensure the response is a string\\n    if not isinstance(response, str):\\n        return False\\n\\n    # Split response into lines\\n    lines = response.strip().split('\\\\n')\\n    if len(lines) < 2:\\n        return False\\n\\n    current_char = 'A'\\n\\n    for line in lines:\\n        # Verify the line starts with an equation involving the ingredient\\n        parts = line.split(':')\\n        if len(parts) != 2:\\n            return False\\n\\n        equation, ingredient = parts[0].strip(), parts[1].strip()\\n\\n        # Check if the first letter of the ingredient matches the expected alphabet letter\\n        if not ingredient or ingredient[0].upper() != current_char:\\n            return False\\n\\n        try:\\n            # Attempt to evaluate the equation part\\n            eval_result = eval(equation)\\n            if not isinstance(eval_result, (int, float)):\\n                return False\\n        except:\\n            return False\\n\\n        # Move to the next character in the alphabet\\n        current_char = chr(ord(current_char) + 1)\\n        if current_char > 'Z':\\n            current_char = 'A'\\n\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"2 + 2 : Apple\\\\n3 * 3 : Banana\\\\n4 / 2 : Carrot\",\n      \"output\": true\n    },\n    {\n      \"input\": \"5 - 2 : Eggplant\\\\n6 ^ 2 : Date\",\n      \"output\": false\n    },\n    {\n      \"input\": \"10 / 5 : Zucchini\\\\n11 * 0 : Artichoke\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    if not response:\\n        return False\\n\\n    equations = response.split('. ')\\n    if not all(equation.strip().endswith('=') for equation in equations if equation):\\n        return False\\n\\n    last_char = None\\n    for equation in equations:\\n        if '=' not in equation:\\n            continue\\n        parts = equation.split(' ')\\n        for part in parts:\\n            if part.isalpha():\\n                if last_char is None:\\n                    last_char = part.lower()\\n                else:\\n                    expected_char = chr(ord(last_char) + 1)\\n                    if part.lower() != expected_char:\\n                        return False\\n                    last_char = part.lower()\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"Apple = 2 units. Banana = 3 units. Carrot = 5 units.\",\n      \"output\": \"True\"\n    },\n    {\n      \"input\": \"Almonds = 100g. Bread = 2 slices. Cake = 1 piece.\",\n      \"output\": \"True\"\n    },\n    {\n      \"input\": \"Chocolate = 10 bars. Apples = 5 units.\",\n      \"output\": \"False\"\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    if not response:\\n        return False\\n\\n    lines = response.strip().split('\\\\n')\\n    if not lines or not all(line.strip() for line in lines):\\n        return False\\n\\n    acceptable_operators = {'+', '-', '*', '/', '=', ' '}\\n    if any(not all(c.isalnum() or c in acceptable_operators for c in line.replace('.', '', 1)) for line in lines):\\n        return False\\n\\n    current_char = 'A'\\n    for line in lines:\\n        if not line.strip().startswith(current_char):\\n            return False\\n        current_char = chr(ord(current_char) + 1)\\n        if current_char > 'Z':\\n            break\\n\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"Apple = 1\\nBanana = 2\\nCarrot = 3\\n\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Apple + 1\\nBanana = 2 - 1\\nCarrot * 3 = 9\\n\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Banana = 2\\nCarrot = 3\\nApple = 1\\n\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    if not response:\\n        return False\\n    lines = response.split('\\\\n')\\n    if not all(line.strip().endswith('=') for line in lines if line.strip()):\\n        return False\\n    ingredients = []\\n    last_char = ''\\n    for line in lines:\\n        if line.strip() and not line.strip().endswith('='):\\n            return False\\n        parts = line.split('=')\\n        if len(parts) != 2:\\n            continue\\n        left, right = parts\\n        ingredient = left.strip()\\n        if not ingredient:\\n            continue\\n        if last_char and (ord(ingredient[0].lower()) - ord(last_char.lower())) != 1:\\n            return False\\n        last_char = ingredient[0]\\n        ingredients.append(ingredient)\\n    if not ingredients:\\n        return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"Apple = 1kg\\\\nBread = 500g\\\\nCucumber = 250g\\\\n\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Banana = 2\\\\nApple = 3\\\\nCarrot = 1\\\\n\",\n      \"output\": false\n    },\n    {\n      \"input\": \"\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    if not response:\\n        return False\\n    lines = response.split('\\\\n')\\n    if not lines:\\n        return False\\n    # Check if equations form a coherent answer, ignoring this part assuming that's outside the scope\\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\\n    current_index = 0\\n    for line in lines:\\n        # Assuming the format is: 'A: apple = 1kg'\\n        parts = line.split(':')\\n        if len(parts) != 2:\\n            return False\\n        ingredient_letter = parts[0].strip().lower()\\n        if ingredient_letter != alphabet[current_index]:\\n            return False\\n        current_index += 1\\n        if current_index >= len(alphabet): # Reached end of alphabet\\n            break\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"A: Apple = 1kg\\\\nB: Banana = 2kg\\\\nC: Carrot = 300g\",\n      \"output\": true\n    },\n    {\n      \"input\": \"A: Apple = 1kg\\\\nC: Carrot = 300g\\\\nB: Banana = 2kg\",\n      \"output\": false\n    },\n    {\n      \"input\": \"\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    import re\\n    # Check for mathematical equations and alphabetical sequence\\n    equations = re.findall(r'([A-Za-z]+) *= *[0-9]+', response)\\n    if not equations:\\n        return False\\n    # Now check if the equations make a sequence\\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\\n    for i, eq in enumerate(equations):\\n        if not eq.lower().startswith(alphabet[i]):\\n            return False\\n    # If all checks pass, it follows the instruction\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"Apple = 2\\nBanana = 3\\nCarrot = 5\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Banana = 2\\nApple = 3\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Almonds = 100\\nBread = 200\\nChocolate = 300\\nDates = 400\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    import string\\n    import re\\n    # Check if the response is empty\\n    if not response:\\n        return False\\n    # Split the response into parts by any mathematical equation signs\\n    parts = re.split(r'[-+*/=]', response)\\n    # Remove whitespace and empty strings from the split parts\\n    parts = [part.strip() for part in parts if part.strip()]\\n    # Check if we have consecutive alphabets starting from any letter\\n    alphabet = string.ascii_lowercase\\n    for i in range(len(parts) - 1):\\n        # Extract the first letter of each part assuming ingredient name\\n        first_letter_current = parts[i][0].lower()\\n        first_letter_next = parts[i+1][0].lower()\\n        # Find position in the alphabet\\n        pos_current = alphabet.find(first_letter_current)\\n        pos_next = alphabet.find(first_letter_next)\\n        # Check if consecutive and next in the alphabet sequence\\n        if pos_next - pos_current != 1:\\n            return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"Apple + Butter = Cake - Dates / Eggs\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Sugar - Honey + Ice = Juice\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Almonds - Blackberries + Coconuts = Delicious\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    if not response:\\n        return False\\n\\n    equations = response.split('.')\\n    if len(equations) <= 1:\\n        return False\\n\\n    letters = 'abcdefghijklmnopqrstuvwxyz'\\n\\n    for i, eq in enumerate(equations):\\n        if not eq.strip():\\n            continue\\n\\n        if i >= len(letters):\\n            return False\\n\\n        expected_letter = letters[i]\\n        parts = eq.split('=')\\n        if len(parts) != 2:\\n            return False\\n\\n        lhs, rhs = parts\\n        lhs = lhs.strip()\\n        rhs = rhs.strip()\\n\\n        if not lhs.startswith(expected_letter) or not rhs.replace(' ', '').isalpha() or ' '+'+'.join(list(rhs.replace(' ', ''))).lower() != lhs.lower():\\n            return False\\n\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"a = apple. b = banana. c = carrot\",\n      \"output\": true\n    },\n    {\n      \"input\": \"a = apple. b = banana c = carrot\",\n      \"output\": false\n    },\n    {\n      \"input\": \"x = xanthan gum. y = yeast. z = zucchini\",\n      \"output\": true\n    }\n  ]\n}\n```"]}
{"prompt": "You are an expert for writing evaluation functions in Python to evaluate whether a response strictly follows an instruction.\nHere is the instruction: Use only words from a specified page of the dictionary. Answer with a list, where each item is one word longer than the previous\nPlease write a Python function named `evaluate` to evaluate whether an input string `response` follows this instruction. If it follows, simply return True, otherwise return False.\nPlease response with a single JSON includes the evaluation function in the key `func`, and a list of three test cases in the key `cases`, which includes an input in the key `input` and an expected output in the key `output` in (true, false).\nHere is an example of output JSON format: {\"func\": JSON_STR(use only \\n instead of \n), \"cases\": [{\"input\": str, \"output\": str}]}.", "instruction": "Use only words from a specified page of the dictionary. Answer with a list, where each item is one word longer than the previous", "gpt-answer": ["```json\n{\n  \"func\": \"def evaluate(response):\\n    # Split the response into a list of words\\n    words = response.strip().split(', ')\\n    # Check if each item in the list is one word longer than the previous\\n    for i in range(len(words) - 1):\\n        if len(words[i+1].split()) - len(words[i].split()) != 1:\\n            return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"apple, big apple, very big apple\",\n      \"output\": true\n    },\n    {\n      \"input\": \"word\",\n      \"output\": true\n    },\n    {\n      \"input\": \"hello, world, quick, brown, fox\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # First, we need to make sure the response is a list of strings\\n    if not isinstance(response, list) or not all(isinstance(item, str) for item in response):\\n        return False\\n\\n    # Secondly, each item should be one word and the list should follow the length criteria\\n    try:\\n        # Split the response into a list of words, then check if each is strictly one word\\n        words = [item for item in response if ' ' not in item and item.isalpha()]\\n        if len(words) != len(response):  # Ensure all items in the response are single-word\\n            return False\\n\\n        # Check the length criteria: each item should be one word longer than the previous\\n        for i in range(1, len(words)):\\n            if len(words[i]) != len(words[i-1]) + 1:\\n                return False\\n    except Exception as e:\\n        return False\\n\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"[\\\"a\\\", \\\"be\\\", \\\"sea\\\"]\",\n      \"output\": \"True\"\n    },\n    {\n      \"input\": \"[\\\"word\\\", \\\"words\\\", \\\"wordss\\\", \\\"notword\\\"]\",\n      \"output\": \"True\"\n    },\n    {\n      \"input\": \"[\\\"one\\\", \\\"two words\\\", \\\"three\\\"]\",\n      \"output\": \"False\"\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    def valid_word_sequence(words, dictionary_words):\\n        if not all(word in dictionary_words for word in words):\\n            return False\\n        for i in range(1, len(words)):\\n            if len(words[i]) != len(words[i-1]) + 1:\\n                return False\\n        return True\\n\\n    # Simulated dictionary page words (for demonstration, usually this should be loaded or passed)\\n    dictionary_page_words = {'apple', 'banana', 'cherry', 'dragonfruit', 'elderberry', 'fig', 'grape', 'honeydew'}\\n\\n    words = response.strip().split(', ')\\n    if not words or '' in words:\\n        return False\\n    return valid_word_sequence(words, dictionary_page_words)\\n\",\n  \"cases\": [\n    {\n      \"input\": \"fig, grape, cherry\",\n      \"output\": true\n    },\n    {\n      \"input\": \"apple, banana, cherry, dragonfruit\",\n      \"output\": true\n    },\n    {\n      \"input\": \"banana, apple, dragonfruit\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Assuming dictionary_page_words is a list of words from the specified dictionary page\\n    dictionary_page_words = set(['word1', 'word2', 'word3', 'word4']) # Example set\\n\\n    try:\\n        # Split the response into a list of words\\n        response_list = response.strip('[]').replace('\\'', '').replace('\\\"', '').split(', ')\\n\\n        # Check if the response is a list format\\n        if not response.startswith('[') or not response.endswith(']'):\\n            return False\\n\\n        # Check if the response follows the increasing length rule\\n        for i in range(1, len(response_list)):\\n            if len(response_list[i]) <= len(response_list[i-1]):\\n                return False\\n\\n        # Check if all the words are from the specified dictionary page\\n        for word in response_list:\\n            if word not in dictionary_page_words:\\n                return False\\n\\n        return True\\n    except:\\n        return False\",\n  \"cases\": [\n    {\n      \"input\": \"['word1', 'word2', 'word3']\",\n      \"output\": \"False\"\n    },\n    {\n      \"input\": \"['word1']\",\n      \"output\": \"True\"\n    },\n    {\n      \"input\": \"['word3', 'word1']\",\n      \"output\": \"False\"\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Assuming the specified page of the dictionary is not provided,\\n    # we will not check for the specific words from the dictionary page.\\n    try:\\n        words = response.split(', ')\\n        list_lengths = [len(word.split()) for word in words]\\n\\n        # Check if each item is one word longer than the previous\\n        for i in range(len(list_lengths) - 1):\\n            if list_lengths[i+1] - list_lengths[i] != 1:\\n                return False\\n        return True\\n    except Exception as e:\\n        # In case of any unforeseen error, consider the response does not follow the instructions\\n        return False\",\n  \"cases\": [\n    {\n      \"input\": \"one, two three, four five six\",\n      \"output\": True\n    },\n    {\n      \"input\": \"apple, banana mango, cherry banana apple\",\n      \"output\": False\n    },\n    {\n      \"input\": \"word, two words, three words now, this is four words\",\n      \"output\": True\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    try:\\n        # Assuming dictionary words are not provided, skipping dictionary validation part\\n        response_list = response.split(', ')\\n        # Check if each item in the list follows the word length pattern\\n        for i in range(1, len(response_list)):\\n            if len(response_list[i].split()) != len(response_list[i-1].split()) + 1:\\n                return False\\n        return True\\n    except Exception as e:\\n        print(f\\\"Error: {e}\\\")\\n        return False\",\n  \"cases\": [\n    {\n      \"input\": \"apple, apple pie, apple pie bake, apple pie bake crust\",\n      \"output\": true\n    },\n    {\n      \"input\": \"quick, quick brown, quick fox jumps\",\n      \"output\": true\n    },\n    {\n      \"input\": \"sky, blue, deep blue sea\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response): \\n    # Split the input into a list of words \\n    words_list = response.split(', ') \\n    \\n    # Check for list format \\n    if not response or response[0] != '[' or response[-1] != ']' or not words_list: \\n        return False \\n    \\n    # Remove brackets for evaluation \\n    words_list[0] = words_list[0][1:] \\n    words_list[-1] = words_list[-1][:-1] \\n    \\n    # Check each item's length increment \\n    for i in range(len(words_list) - 1): \\n        if len(words_list[i+1].split()) <= len(words_list[i].split()): \\n            return False \\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"[a, a b, a b c]\",\n      \"output\": true\n    },\n    {\n      \"input\": \"[apple, banana]\",\n      \"output\": false\n    },\n    {\n      \"input\": \"[one, two three, four five six]\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # First, split the response into a list of words\\n    words = response.split(', ')\\n\\n    # Check if the list starts with a single word, and each subsequent item has one word more\\n    for i in range(len(words) - 1):\\n        if len(words[i].split()) + 1 != len(words[i + 1].split()):\\n            return False\\n\\n    # Assuming the dictionary check is abstracted as it requires an external data source\\n\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"apple, apple banana, apple banana carrot\",\n      \"output\": true\n    },\n    {\n      \"input\": \"one, two, three four\",\n      \"output\": false\n    },\n    {\n      \"input\": \"dog, dog cat, dog cat mouse, dog cat mouse bird\",\n      \"output\": true\n    }\n  ]\n}\n```"]}
{"prompt": "You are an expert for writing evaluation functions in Python to evaluate whether a response strictly follows an instruction.\nHere is the instruction: Write your answer as a series of rhetorical questions. Write the response as if it's a series of hashtags\nPlease write a Python function named `evaluate` to evaluate whether an input string `response` follows this instruction. If it follows, simply return True, otherwise return False.\nPlease response with a single JSON includes the evaluation function in the key `func`, and a list of three test cases in the key `cases`, which includes an input in the key `input` and an expected output in the key `output` in (true, false).\nHere is an example of output JSON format: {\"func\": JSON_STR(use only \\n instead of \n), \"cases\": [{\"input\": str, \"output\": str}]}.", "instruction": "Write your answer as a series of rhetorical questions. Write the response as if it's a series of hashtags", "gpt-answer": ["```json\n{\n  \"func\": \"def evaluate(response):\\n    if not response.startswith('#') or '?' in response:\\n        return False\\n    hashtags = response.split()\\n    for tag in hashtags:\\n        if not tag.startswith('#') or '?' in tag:\\n            return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"#IsThisHowWeDoIt #ButWhyIsThat #CouldItBeOtherwise\",\n      \"output\": false\n    },\n    {\n      \"input\": \"#ThisIsNotARhetoricalQuestion?\",\n      \"output\": false\n    },\n    {\n      \"input\": \"#JustAHashtag #AnotherOne\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Check if the response is a string of hashtags without spaces or other characters\\n    if not response.startswith('#') or ' ' in response:\\n        return False\\n    # Split the response into individual hashtags\\n    hashtags = response.split('#')\\n    # Remove the first empty string due to split at the first character being '#'\\n    hashtags = list(filter(None, hashtags))\\n    # Check if there's at least one hashtag, implying at least one 'question'\\n    if len(hashtags) == 0:\\n        return False\\n    # Check each hashtag to ensure it's not forming a standard question\\n    for tag in hashtags:\\n        if '?' in tag:\\n            return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"#IsThisRight?#HowAboutThis?\",\n      \"output\": false\n    },\n    {\n      \"input\": \"#CouldThisBe#WhatWeAreLookingFor#IsntIt\",\n      \"output\": true\n    },\n    {\n      \"input\": \"#WhyIsThis #NotCorrect?\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    if not response:\\n        return False\\n    # Hashtags don't include question marks by nature, implying it cannot be a rhetorical question.\\n    # The instruction contradicts itself by asking for responses as a series of rhetorical questions but in the form of hashtags.\\n    # Thus, under strict interpretation, no response can truly follow the instructions as given.\\n    # Given the inherent contradiction, a loose interpretation would check for hashtag form only.\\n    response_elements = response.strip().split()\\n    for element in response_elements:\\n        if not element.startswith('#'):\\n            return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"#IsThisHowWeDoIt #AreWeFollowingTheInstructionsCorrectly\",\n      \"output\": \"True\"\n    },\n    {\n      \"input\": \"Just a normal response, not following the instructions.\",\n      \"output\": \"False\"\n    },\n    {\n      \"input\": \"#ThisIsGood #ButWhat#IfWeMessUp\",\n      \"output\": \"False\"\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Check if the response is completely made up of hashtag elements\\n    if not response:\\n        return False\\n    hashtags = response.split()\\n    for tag in hashtags:\\n        if not tag.startswith('#'):\\n            return False\\n    # Check there are no rhetorical questions in hashtags as per instruction\\n    return all('?' not in tag for tag in hashtags)\\n\",\n  \"cases\": [\n    {\n      \"input\": \"#WhyWouldYouThinkSo? #IsntItObvious? #CouldItBe?\",\n      \"output\": false\n    },\n    {\n      \"input\": \"#ThisIsNotAQuestion #NeitherIsThis #NorThis\",\n      \"output\": true\n    },\n    {\n      \"input\": \"#WhyIsTheSkyBlue? #WhatMakesTheWorldGoRound?\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Check if response is empty or not a string\\n    if not response or not isinstance(response, str):\\n        return False\\n    \\n    # Check if response starts and ends with hashtags and has any non-hashtag content\\n    if not response.startswith('#') or ' #' not in response:\\n        return False\\n    \\n    # Split the response to analyze each part\\n    parts = response.split(' #')\\n    \\n    # Check if any part of the response is not a rhetorical question\\n    for part in parts:\\n        if not part.endswith('?'):\\n            return False\\n    \\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"#Isn't it odd? #What about the consequences? #And the future?\",\n      \"output\": true\n    },\n    {\n      \"input\": \"#This is not a question.\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Isn't it odd? What about the consequences? And the future?\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    if not response.startswith('#') or '?' not in response:\\n        return False\\n    hashtags = response.split()\\n    for tag in hashtags:\\n        if not tag.startswith('#') or '?' not in tag:\\n            return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"#IsThisNotARhetoricalQuestion? #OrIsIt?\",\n      \"output\": true\n    },\n    {\n      \"input\": \"#WhyUseHashtags #ThisIsNotRhetorical.\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Just some text without hashtags.\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Check if response is empty or not a string\\n    if not response or not isinstance(response, str):\\n        return False\\n    # Split the response on spaces\\n    tokens = response.split()\\n    # Check if all items are hashtags\\n    hashtags_only = all(token.startswith('#') for token in tokens)\\n    if not hashtags_only:\\n        return False\\n    # Assuming rhetorical questions must end with a question mark,\\n    # check if any hashtag ends with '?'\\n    questions_only = all(token.endswith('?') for token in tokens)\\n    if not questions_only:\\n        return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"#Isn'tItStrange? #WhoWouldHaveThought? #WhyIsThisSo?\",\n      \"output\": true\n    },\n    {\n      \"input\": \"#ThisIsNotAQuestion.\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Isn't this a series of weird questions?\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Split the response into parts based on whitespaces\\n    parts = response.split()\\n    # Check if all parts are hashtags (start with #)\\n    if not all(part.startswith('#') for part in parts):\\n        return False\\n    # Now, we need to check if these are rhetorical questions. Since the instruction\\n    # was to write responses as hashtags, and rhetorical questions typically end with a question mark,\\n    # which cannot be part of a hashtag, this scenario creates a paradox.\\n    # Thus, we interpret rhetorical questions as those that could imply a question\\n    # without explicitly using a question mark, making this a subjective interpretation.\\n    # For simplicity, we return True as the instructions are contradictory in the asked format.\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"#IsThisHowWeDoIt #OrIsThereAnotherWay\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Is this a rhetorical question?\",\n      \"output\": false\n    },\n    {\n      \"input\": \"#MaybeThis #IsTheWay #ToAsk?\",\n      \"output\": true\n    }\n  ]\n}\n```"]}
{"prompt": "You are an expert for writing evaluation functions in Python to evaluate whether a response strictly follows an instruction.\nHere is the instruction: Use words that can be mirrored vertically (e.g., \"wow\", \"mow\"). Write the response as a series of computer programming instructions\nPlease write a Python function named `evaluate` to evaluate whether an input string `response` follows this instruction. If it follows, simply return True, otherwise return False.\nPlease response with a single JSON includes the evaluation function in the key `func`, and a list of three test cases in the key `cases`, which includes an input in the key `input` and an expected output in the key `output` in (true, false).\nHere is an example of output JSON format: {\"func\": JSON_STR(use only \\n instead of \n), \"cases\": [{\"input\": str, \"output\": str}]}.", "instruction": "Use words that can be mirrored vertically (e.g., \"wow\", \"mow\"). Write the response as a series of computer programming instructions", "gpt-answer": ["```json\n{\n  \"func\": \"def evaluate(response):\\n    valid_chars = set('AHIKMOTUVWXYowvmu')\\n\\n    def is_mirror_word(word):\\n        for char in word:\\n            if char not in valid_chars:\\n                return False\\n        return True\\n    \\n    instructions = response.split()\\n    for instruction in instructions:\\n        if not is_mirror_word(instruction):\\n            return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"wow mow\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Programming is fun\",\n      \"output\": false\n    },\n    {\n      \"input\": \"MOw WoW\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    mirrorable_chars = set('AHIKMOTUVWXYowmvx')  # Characters that look the same mirrored vertically\\n    words = response.split()\\n    for word in words:\\n        # Checking every character in the word\\n        for char in word:\\n            if char not in mirrorable_chars:\\n                return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"wow mow\",\n      \"output\": True\n    },\n    {\n      \"input\": \"Programming is fun\",\n      \"output\": False\n    },\n    {\n      \"input\": \"wow ovv mow\",\n      \"output\": True\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response): \\n    mirrored_words = set(['wow', 'mow'])\\n    words = response.split()\\n    for word in words:\\n        if word not in mirrored_words:\\n            return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"wow mow wow\",\n      \"output\": true\n    },\n    {\n      \"input\": \"wow sow\",\n      \"output\": false\n    },\n    {\n      \"input\": \"mow wow\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Characters that can be mirrored vertically and still read the same\\n    valid_chars = 'AHIKMOTUVWXY'.lower() + 'bdow'\\n    words = response.split()\\n    for word in words:\\n        # Remove any characters that are not part of word syntax in programming (variables, function names)\\n        clean_word = ''.join(filter(str.isalnum, word))\\n        # Check each word if it's made of only valid characters for vertical mirroring\\n        for char in clean_word.lower():\\n            if char not in valid_chars:\\n                return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"int mow = wow + mom;\",\n      \"output\": true\n    },\n    {\n      \"input\": \"float boat = 1.0;\",\n      \"output\": false\n    },\n    {\n      \"input\": \"void myFunc() { int wow = 2; }\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Define vertically mirrored characters\\n    valid_chars = set(\\\"AHIMOTUVWXYowvm\\\").union(set(' ')) # includes space for word separation\\n    # Split response into words and iterate over them\\n    for word in response.split():\\n        # Check each character in the word\\n        for char in word:\\n            if char not in valid_chars:\\n                return False\\n        # Check if the word is not symmetric\\n        if word != word[::-1]:\\n            return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"wow mow\",\n      \"output\": true\n    },\n    {\n      \"input\": \"python programming\",\n      \"output\": false\n    },\n    {\n      \"input\": \"woow\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    mirrorable_letters = set('owvmAHTIOX')  # Set of characters that look the same when mirrored vertically.\\n    \\n    # Splitting the response into words\\n    words = response.split()\\n    \\n    # Checking each word\\n    for word in words:\\n        for char in word:\\n            # If a character is not in the set of mirrorable letters, return False\\n            if char.lower() not in mirrorable_letters:\\n                return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"wow mow\",\n      \"output\": true\n    },\n    {\n      \"input\": \"hello world\",\n      \"output\": false\n    },\n    {\n      \"input\": \"moW WoW\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Define a set of characters that can appear in vertically mirrored words\\n    valid_chars = set('owvmAHTIOX')\\n    # Split the response into words\\n    words = response.split()\\n    # Check each word if it only contains valid characters\\n    for word in words:\\n        if not all(char in valid_chars for char in word):\\n            return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"wow mow\",\n      \"output\": true\n    },\n    {\n      \"input\": \"hello world\",\n      \"output\": false\n    },\n    {\n      \"input\": \"moo wow\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # List of letters that can be mirrored vertically\\n    valid_letters = set('owmv')\\n    \\n    # Split the response into words\\n    words = response.split()\\n    \\n    # Check each word in the response\\n    for word in words:\\n        # Remove invalid characters considering programming syntax\\n        cleaned_word = ''.join(filter(str.isalpha, word))\\n        \\n        # Check if the word consists only of valid letters\\n        if not all(letter in valid_letters for letter in cleaned_word.lower()):\\n            return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"print('wow') # This is a comment\",\n      \"output\": true\n    },\n    {\n      \"input\": \"for i in range(10): print('mom')\",\n      \"output\": true\n    },\n    {\n      \"input\": \"if x == 'boom': print('No!')\",\n      \"output\": false\n    }\n  ]\n}\n```"]}
{"prompt": "You are an expert for writing evaluation functions in Python to evaluate whether a response strictly follows an instruction.\nHere is the instruction: Answer with words that each contain at least two 's's. Answer by including a prime number of words in each sentence\nPlease write a Python function named `evaluate` to evaluate whether an input string `response` follows this instruction. If it follows, simply return True, otherwise return False.\nPlease response with a single JSON includes the evaluation function in the key `func`, and a list of three test cases in the key `cases`, which includes an input in the key `input` and an expected output in the key `output` in (true, false).\nHere is an example of output JSON format: {\"func\": JSON_STR(use only \\n instead of \n), \"cases\": [{\"input\": str, \"output\": str}]}.", "instruction": "Answer with words that each contain at least two 's's. Answer by including a prime number of words in each sentence", "gpt-answer": ["```json\n{\n  \"func\": \"def is_prime(n):\\n    if n <= 1:\\n        return False\\n    for i in range(2, int(n**0.5) + 1):\\n        if n % i == 0:\\n            return False\\n    return True\\n\\ndef evaluate(response):\\n    words = response.split()\\n    if not is_prime(len(words)):\\n        return False\\n    for word in words:\\n        if word.count('s') < 2:\\n            return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"Assesses possess sessions\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Success is not absolute\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Classes grasses masses\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    def is_prime(n):\\n        if n <= 1:\\n            return False\\n        for i in range(2, int(n**0.5) + 1):\\n            if n % i == 0:\\n                return False\\n        return True\\n\\n    def follows_rule(word):\\n        return word.count('s') >= 2\\n\\n    words = response.split()\\n    all_follow = all(follows_rule(word) for word in words)\\n    return all_follow and is_prime(len(words))\\n\",\n  \"cases\": [\n    {\n      \"input\": \"Assessments usually possess essentials.\",\n      \"output\": true\n    },\n    {\n      \"input\": \"sessions missed\",\n      \"output\": true\n    },\n    {\n      \"input\": \"This sentence does not comply.\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    def is_prime(n):\\n        if n <= 1:\\n            return False\\n        for i in range(2, int(n**0.5) + 1):\\n            if n % i == 0:\\n                return False\\n        return True\\n\\n    words = response.split()\\n    if not is_prime(len(words)):\\n        return False\\n\\n    for word in words:\\n        if word.count('s') < 2:\\n            return False\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"Assessments usually stress students.\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Assessment passes.\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Classes dismissed.\",\n      \"output\": false\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    # Check if a number is prime\\n    def is_prime(n):\\n        if n <= 1:\\n            return False\\n        for i in range(2, int(n**0.5) + 1):\\n            if n % i == 0:\\n                return False\\n        return True\\n\\n    # Split the response into words\\n    words = response.split()\\n\\n    # Check if the number of words is prime\\n    if not is_prime(len(words)):\\n        return False\\n\\n    # Check each word for at least two 's's\\n    for word in words:\\n        if word.count('s') < 2:\\n            return False\\n\\n    return True\",\n  \"cases\": [\n    {\n      \"input\": \"This possesses essentials.\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Mississippi passes tests seamlessly.\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Dresses, classes, and assessments.\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    def is_prime(n):\\n        if n <= 1:\\n            return False\\n        for i in range(2, int(n**0.5) + 1):\\n            if n % i == 0:\\n                return False\\n        return True\\n\\n    sentences = [sentence.strip() for sentence in response.split('.') if sentence]\\n    for sentence in sentences:\\n        words = sentence.split()\\n        if not is_prime(len(words)):\\n            return False\\n        for word in words:\\n            if word.count('s') < 2:\\n                return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"Assessments and possessions.\",\n      \"output\": \"False\"\n    },\n    {\n      \"input\": \"Assess, possessions, sessions.\",\n      \"output\": \"True\"\n    },\n    {\n      \"input\": \"Dresses have pressing issues.\",\n      \"output\": \"False\"\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def is_prime(n):\\n    if n <= 1:\\n        return False\\n    for i in range(2, int(n**0.5) + 1):\\n        if n % i == 0:\\n            return False\\n    return True\\n\\ndef evaluate(response):\\n    words = response.split()\\n    if not is_prime(len(words)):\\n        return False\\n    for word in words:\\n        if word.count('s') < 2:\\n            return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"Assessments usually possess challenges.\",\n      \"output\": \"True\"\n    },\n    {\n      \"input\": \"Some sentences simply don't qualify.\",\n      \"output\": \"False\"\n    },\n    {\n      \"input\": \"Mississippi's desserts are tasteless.\",\n      \"output\": \"False\"\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    def is_prime(n):\\n        if n < 2:\\n            return False\\n        for i in range(2, int(n**0.5) + 1):\\n            if n % i == 0:\\n                return False\\n        return True\\n\\n    def has_two_s(word):\\n        return word.count('s') >= 2\\n\\n    words = response.split()\\n    if not is_prime(len(words)):\\n        return False\\n    for word in words:\\n        if not has_two_s(word):\\n            return False\\n    return True\\n\",\n  \"cases\": [\n    {\n      \"input\": \"Assessments usually possess strengths.\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Some words satisfy conditions.\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Classes assesses stresses.\",\n      \"output\": true\n    }\n  ]\n}\n```", "```json\n{\n  \"func\": \"def evaluate(response):\\n    def is_prime(n):\\n        if n <= 1:\\n            return False\\n        for i in range(2, int(n**0.5) + 1):\\n            if n % i == 0:\\n                return False\\n        return True\\n\\n    def word_meets_condition(word):\\n        return word.count('s') >= 2\\n\\n    words = response.split()\\n    num_words_meet_condition = sum(word_meets_condition(word) for word in words)\\n    return is_prime(len(words)) and num_words_meet_condition == len(words)\\n\",\n  \"cases\": [\n    {\n      \"input\": \"Assessments are useless.\",\n      \"output\": false\n    },\n    {\n      \"input\": \"Masses possess passes.\",\n      \"output\": true\n    },\n    {\n      \"input\": \"Lessons stresses successes.\",\n      \"output\": false\n    }\n  ]\n}\n```"]}
