{"instruction": "Use no words containing the letter 'E'", "eval_func": [["def evaluate(response):\n    return 'e' not in response.lower()", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if 'e' in word.lower():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    return all('e' not in word.lower() for word in response.split())", 1.0], ["def evaluate(response):\n    for word in response.split():\n        if 'e' in word.lower():\n            return False\n    return True", 1.0]], "cases": [["My lip", true], ["Every cloud has a silver lining", false], ["My cat is big", true], ["Hi, amigo!", true], ["Hi world", true], ["A shy dog.", true]], "back_instruction": ["Answer without using any words that contain the letter 'E'.", "Answer with words that do not contain the letter 'E'.", "Answer with words that do not contain the letter 'E'."]}
{"instruction": "Use only words with double letters (e.g., \"bookkeeper\")", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not any(char*2 in word for char in set(word)):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not any(c1 == c2 for c1, c2 in zip(word, word[1:])):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    def has_double_letters(word):\n        for i in range(len(word) - 1):\n            if word[i] == word[i + 1]:\n                return True\n        return False\n    words = response.split()\n    for word in words:\n        if not has_double_letters(word):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    def has_double_letters(word):\n        for i in range(len(word) - 1):\n            if word[i] == word[i + 1]:\n                return True\n        return False\n\n    words = response.split()\n    for word in words:\n        if not has_double_letters(word):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not any(char * 2 in word for char in set(word)):\n            return False\n    return True", 1.0], ["def evaluate(response): \n    words = response.split() \n    for word in words: \n        if not any(char * 2 in word for char in set(word)): \n            return False \n    return True", 1.0], ["def evaluate(response):\n  words = response.split()\n  for word in words:\n    if not any(c1 == c2 for c1, c2 in zip(word, word[1:])):\n      return False\n  return True", 1.0]], "cases": [["Happy birthday to you!", false], ["All good men", false], ["bookkeeper needed immediately", true], ["happy balloon", true], ["The moon looked stunning.", false], ["bookkeeper unnecessary", true], ["add bee", true], ["bookkeeper happy coffee", true], ["bassoon committee", true], ["happy apple tree", true], ["bassoon addressee", true], ["an apple a day", false], ["The quick brown fox", false], ["The bookkeeper arranged the letters", false], ["address assessment", true], ["every letter", false], ["bookkeeper address", true], ["bookkeeper addressed", true], ["happy feet", true]], "back_instruction": ["Answer with words where every word has at least one letter repeated consecutively.", "Answer with words that contain at least one pair of consecutive letters that are the same.", "Ensure every word in your answer contains at least one instance of the same letter occurring back-to-back."]}
{"instruction": "Use only palindromes", "eval_func": [["def evaluate(response):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    words = response.split()\n    return all(is_palindrome(word) for word in words)", 1.0], ["def evaluate(response):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    words = response.split()\n    for word in words:\n        if not is_palindrome(word):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    def is_palindrome(s):\n        return s == s[::-1]\n    words = response.split()\n    return all(is_palindrome(word) for word in words)", 1.0]], "cases": [["madam racecar", true], ["deed deed", true], ["Python", false], ["civic level radar", true], ["python", false], ["madam civic rotator", true], ["level kayak radar", true], ["hello world", false], ["level racecar kayak", true], ["level civic radar", true], ["racecar", true], ["palindrome", false], ["madam anna kayak", true], ["madam civic racecar", true], ["racecar level civic", true], ["palindrome racecar", false]], "back_instruction": ["Answer with words that are palindromes.", "Answer with words that are palindromes.", "Answer with words that are palindromes."]}
{"instruction": "Use words that end with '-ing'", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word.endswith('-ing'):\n            return False\n    return True", 0.9], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word.endswith('-ing'):\n            return False\n    return len(words) > 0", 1.0], ["def evaluate(response):\n    # Split the response into words to evaluate each one\n    words = response.split()\n    # Check if all words end with '-ing'\n    for word in words:\n        if not word.endswith('-ing'):\n            return False\n    return True", 0.9], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word.endswith('-ing'):\n            return False\n    return True if words else False", 1.0]], "cases": [["Running jumping laughing", false], ["", false], ["I am enjoying the thrilling coding session.", false], ["Walking on planning meeting.", false], ["I am looking for something interesting", false], ["I am running and jumping", false], ["Running but stopped", false], ["This is a test", false], ["She is walking quickly.", false], ["Reading a book", false]], "back_instruction": ["Answer with all words ending in '-ing'.", "Answer with all words ending in '-ing', ensuring at least one word is present.", "Answer with all words ending in '-ing'."]}
{"instruction": "Answer with words in alphabetical order", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for i in range(len(words) - 1):\n        if words[i] > words[i + 1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    sorted_words = sorted(words, key=str.lower)\n    return words == sorted_words", 1.0], ["def evaluate(response):\n    words = response.split()\n    lowercase_words = [word.lower() for word in words]\n    sorted_words = sorted(lowercase_words)\n    return lowercase_words == sorted_words", 1.0], ["def evaluate(response):\n    words = response.split()\n    sorted_words = sorted(words)\n    return words == sorted_words", 1.0]], "cases": [["apple banana mango", true], ["The quick brown fox", false], ["a bee comes dandelion every flower garden", true], ["all bees can do", true], ["apple banana cherry", true], ["zoo goes by", false], ["a beautiful calm day", true], ["an apple grows on trees", true], ["banana apple cherry", false], ["coming dawn breaks", false], ["ant bee cat dog", true], ["a b c", true], ["banana apple", false], ["beautiful flowers bloom", false], ["an elephant jumps kindly", true]], "back_instruction": ["Answer with words in ascending alphabetical order.", "Answer with words in ascending alphabetical order, considering case-insensitive sorting.", "Answer with words in ascending alphabetical order, explicitly considering case-insensitive sorting."]}
